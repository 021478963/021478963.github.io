<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <title>Longest Valid Parentheses</title>
</head>

<body>
  <header>
    <a href="https://leetcode.com/problems/longest-valid-parentheses/">
      <h1 class="main-title">Longest Valid Parentheses</h1>
    </a>
    <a href="../index.html" class="top-nav">Home</a>
  </header>

  <main>
    <section class="page-info">
      <p class="intro-paragraph">
        Apparently I've attempted this question before, but I never got it to succeed. I think
        I have an idea of how to do it now though, with depths.
      </p>
      
      <h2 class="question-title">The Question</h2>
      <blockquote class="question-content">
        Given a string containing just the characters '(' and ')', find the length of the 
        longest valid (well-formed) parentheses substring.
      </blockquote>
    </section>

    <section class="page-description">
      <h2 class="thoughts-title">My Thoughts</h2>

      <p class="following-paragraph">
        The only way for a pair of parentheses to be valid would mean that I the closing parentheses
        would have to be on the same depth as the opening parentheses. However if I ever go below 
        that depth, all opening parentheses on that depth are no longer valid for substring length.
      </p>

      <p class="following-paragraph">
        I think this is doable with a dictionary, in which I will point depths to their first seen 
        indicies. Whenever I decrease depth, I also remove the entry from the dictionary. If I don't
        remove a depth, it means all entires between the two points are valid.
      </p>

      <p class="following-paragraph">
        I will add the key to the current position before adding the depth when I see an opening
        parentheses, in order to maintain symmetry to when I remove. Furthermore, I will calculate
        the length every time depth goes down, by seeing if the depth is in the dictionary.
      </p>

      <p class="following-paragraph">The rough layout for my code is as follows:</p>
      <ol class="list--ordered">
        <li class="list__item">
          I make a dict to keep track of where things begin, a depth counter, and a max length counter
        </li>
        <li class="list__item">
          I iterate through all things in the inpupt
        </li>
        <li class="list__item">
          If the character is <code>"(,"</code> then I will add the current depth to the dictionary
          if it's not already in there, and then increment the depth
        </li>
        <li class="list__item">
          Otherwise, I will check if the depth I'm going into is in the dictionary. If it is, I will
          update the longest chain. I will also remove the depth I'm leaving from the dictionary.
        </li>
      </ol>

      <div class="code-demonstration">
        <code>
def longestValidParentheses(self, s: str) -> int:
depth = 0
max_length = 0
current = {}

for i in range(len(s)):
    # print(depth, current)
    if s[i] == '(':
        if depth not in current.keys():
            current[depth] = i
        depth = depth + 1
    else:
        current.pop(depth, None)
        depth = depth - 1
        if depth in current.keys():
            max_length = max(max_length, 1 + i - current[depth])

return max_length
        </code>
      </div>
    </section>

    <section class="page__reflection">
      <h2 class="reflection-title">Closing thoughts</h2>

      <h3 class="complexity-title">Runtime Complexity: O(n)</h3>
      <p class="following-paragraph">
        I go through all the elements once in the array, and I do a few operations per element.
      </p>
      <h3 class="complexity-title">Space Complexity: O(1)</h3>
      <p class="following-paragraph">
        Worst case scenario, I keep increasing depth every iteration and I need to store all of
        the depths in the dictionary.
      </p>

      <p class="following-paragraph">
        Damn, what a hard question. I'm still glad I completed it though, and hopefully in the
        future I'll get a better runtime. However, O(n) isn't the worst, it's just that I could
        probably better decide when to do the dictionary operations.
      </p>
    </section>
  </main>
</body>
</html>


<!-- 
  header
    main-title
    header__nav
    nav__link-group
    nav__link__item
  
  section
    page-info
      intro-paragraph
    page-description
      following-paragraph
      
  list--ordered
    list__item

  code-demonstration

  checklist:
    1. title, main title
    2. page info, intro paragraph
    3. following paragraph
 -->
